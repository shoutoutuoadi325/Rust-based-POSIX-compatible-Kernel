# RPOS 内核架构设计

## 概述

RPOS（基于 Rust 的 POSIX 兼容操作系统）是一个从零开始使用 Rust 为 RISC-V 64 位架构设计的单内核。该内核提供 POSIX 兼容的系统调用，以支持运行简单的基于 C 的用户应用程序。

## 设计理念

### 为什么选择 Rust？
- **内存安全**: Rust 的所有权系统在编译时防止内存泄漏、缓冲区溢出和数据竞争
- **零成本抽象**: 高级构造无运行时开销
- **无垃圾回收**: 适合内核开发的可预测性能
- **强类型系统**: 在编译时捕获错误

### 为什么选择 POSIX 兼容？
- **丰富的生态系统**: 利用现有的 POSIX 兼容软件
- **标准接口**: 定义明确的系统调用接口
- **可移植性**: 易于从其他 POSIX 系统移植应用程序
- **教育价值**: 从已建立的 OS 设计模式中学习

## 系统架构

```
┌─────────────────────────────────────────────────────┐
│                 用户空间                            │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐         │
│  │  Shell   │  │  应用1   │  │  应用2   │         │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘         │
└───────┼─────────────┼─────────────┼───────────────┘
        │             │             │
        │    系统调用接口 (POSIX)
        │             │             │
┌───────┼─────────────┼─────────────┼───────────────┐
│       │             │             │               │
│  ┌────┴─────────────┴─────────────┴────┐         │
│  │      系统调用分发器                  │         │
│  └─────┬─────────┬─────────┬────────────┘         │
│        │         │         │                      │
│  ┌─────┴──┐ ┌────┴───┐ ┌──┴─────┐  ┌──────────┐ │
│  │进程管理│ │文件系统│ │内存管理│  │陷阱处理  │ │
│  └────────┘ └────────┘ └────────┘  └──────────┘ │
│                                                   │
│  ┌────────────────────────────────────────────┐  │
│  │          硬件抽象层                       │  │
│  │  ┌──────┐  ┌──────┐  ┌────────┐          │  │
│  │  │ SBI  │  │ MMU  │  │ 定时器 │          │  │
│  │  └──────┘  └──────┘  └────────┘          │  │
│  └────────────────────────────────────────────┘  │
│                内核空间                          │
└───────────────────────────────────────────────────┘
        │             │             │
┌───────┼─────────────┼─────────────┼───────────────┐
│       │             │             │               │
│    RISC-V 64位硬件 (物理/QEMU)                    │
└───────────────────────────────────────────────────┘
```

## 核心模块

### 1. 启动与初始化 (`src/main.rs`, `src/entry.asm`)

**职责：**
- 在监督模式下设置初始栈指针
- 清零 BSS 段
- 初始化所有内核子系统
- 将控制权转移到 Rust 入口点

**实现细节：**
- 汇编入口点 `_start` 设置栈
- 跳转到 Rust 的 `rust_main()`
- 使用 SBI（监督二进制接口）获取 M 模式服务

### 2. 内存管理 (`src/mm/`)

**组件：**

#### 地址类型 (`address.rs`)
- `PhysAddr` / `VirtAddr`: 物理和虚拟地址
- `PhysPageNum` / `VirtPageNum`: 页号
- 类型安全的转换和计算

#### 帧分配器 (`frame_allocator.rs`)
- **算法**: 基于栈的分配
- **RAII 模式**: `FrameTracker` 在 drop 时自动释放
- **线程安全**: 由 `UPSafeCell` 保护

#### 堆分配器 (`heap_allocator.rs`)
- **算法**: 伙伴系统（32 级）
- **大小**: 3MB 内核堆
- **全局分配器**: 实现 Rust 的全局分配器 trait

#### 页表 (`page_table.rs`)
- **方案**: SV39（3 级页表）
- **特性**:
  - 虚拟地址转换
  - 页表项标志（V, R, W, X, U, G, A, D）
  - 页表的自动帧分配
  - 页表清理的 RAII

**内存布局：**
```
┌─────────────────────────────────────┐ 0xFFFFFFFF_FFFFFFFF
│      不可访问                       │
├─────────────────────────────────────┤ TRAMPOLINE
│      跳板页                         │
├─────────────────────────────────────┤ TRAP_CONTEXT
│      陷阱上下文                     │
├─────────────────────────────────────┤
│      用户栈                         │
├─────────────────────────────────────┤
│      用户堆                         │
├─────────────────────────────────────┤
│      用户数据/BSS                   │
├─────────────────────────────────────┤
│      用户代码                       │
├─────────────────────────────────────┤ 0x10000
│      (保留)                         │
├─────────────────────────────────────┤ 0x0
└─────────────────────────────────────┘
```

### 3. 陷阱处理 (`src/trap/`)

**组件：**

#### 陷阱上下文 (`context.rs`)
- 保存所有通用寄存器（x0-x31）
- 保存 `sstatus` 和 `sepc`
- 用于上下文切换

#### 陷阱处理器 (`mod.rs`)
- **异常**: 系统调用、页错误、非法指令
- **中断**: 定时器中断
- **入口/出口**: `trap.S` 中的汇编代码

**陷阱流程：**
1. 硬件保存 `sepc`、`scause`、`stval`
2. 跳转到 `__alltraps`（汇编）
3. 将所有寄存器保存到内核栈
4. 在 Rust 中调用 `trap_handler()`
5. 从陷阱上下文恢复寄存器
6. `sret` 返回

### 4. 系统调用 (`src/syscall/`)

**已实现的 POSIX 系统调用：**

| 系统调用 | ID | 描述 |
|---------|-----|-------------|
| read | 63 | 从文件描述符读取 |
| write | 64 | 写入文件描述符 |
| exit | 93 | 退出进程 |
| yield | 124 | 让出 CPU |
| getpid | 172 | 获取进程 ID |
| fork | 220 | 复制进程 |
| execve | 221 | 执行程序 |
| wait4 | 260 | 等待进程 |

**系统调用流程：**
1. 用户应用执行 `ecall` 指令
2. 陷入内核模式
3. 系统调用分发器从 `x17` 读取系统调用号
4. 参数在 `x10`、`x11`、`x12`
5. 调用适当的系统调用处理器
6. 返回值在 `x10`

### 5. 进程管理（待实现）

**任务控制块（TCB）：**
- 进程 ID
- 父进程 ID
- 进程状态（就绪、运行、阻塞、僵尸）
- 页表
- 陷阱上下文
- 内核栈
- 文件描述符表

**调度器：**
- **算法**: 轮转调度
- **时间片**: 可配置量子
- **优先级**: 未来增强

### 6. 文件系统（待实现）

**虚拟文件系统（VFS）：**
- 抽象文件操作（open、read、write、close）
- 文件描述符管理（0=stdin、1=stdout、2=stderr）

**实现选项：**
1. 嵌入式文件系统（将用户二进制文件链接到内核）
2. 块设备的 FAT32 驱动程序
3. 简单的内存文件系统

## 硬件接口

### SBI（监督二进制接口）
- **控制台 I/O**: putchar/getchar
- **定时器**: 设置定时器中断
- **关机**: 关闭机器

### RISC-V 特权级
- **M 模式（机器）**: OpenSBI 固件
- **S 模式（监督）**: RPOS 内核
- **U 模式（用户）**: 用户应用程序

### 使用的 CSR 寄存器
- `sstatus`: 监督状态
- `stvec`: 陷阱向量
- `sepc`: 异常 PC
- `scause`: 陷阱原因
- `stval`: 陷阱值
- `satp`: 地址转换

## 安全考虑

### 内存安全
- Rust 的所有权防止常见漏洞
- 无释放后使用、无双重释放
- 用户缓冲区的边界检查

### 特权分离
- 用户模式 vs 监督模式
- 系统调用验证用户指针
- 用户空间无直接硬件访问

### 页保护
- 用户页面标记 U 标志
- 内核页面不可从用户模式访问
- fork() 的写时复制

## 性能优化

### 编译时优化
- 启用 LTO（链接时优化）
- Release 构建的 Opt-level 3
- 零成本抽象

### 运行时优化
- 伙伴分配器快速分配
- RAII 自动清理
- 系统调用中最小化复制

## 未来增强

1. **多处理器支持**: SMP 调度
2. **高级调度器**: 基于优先级、CFS
3. **网络栈**: TCP/IP 支持
4. **设备驱动**: 块设备、字符设备
5. **IPC**: 管道、共享内存、消息队列
6. **信号**: POSIX 信号处理
7. **动态加载**: 从磁盘加载用户程序

## 参考文献

- RISC-V 特权架构规范
- POSIX.1-2017 标准
- Rust 嵌入式手册
- rCore 教程
