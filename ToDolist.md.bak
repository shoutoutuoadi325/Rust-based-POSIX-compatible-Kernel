# **操作系统比赛：非代码任务执行清单**

**目标**：最大化评分标准中的文档分（30%）、教学分（10%）、规范分（10%）和展示分（20%）。

## **第一阶段：工程规范建设 (对应评分：10%)**

*必须在写第一行代码前完成，并贯穿全程*

* \[ \] **Git 提交规范**  
  * 规定 Commit Message 格式：Type(Scope): Description  
  * *示例*：feat(mm): add buddy system allocator / docs(readme): update build instructions  
  * *工具*：配置 git hook 或使用 commitizen。  
* \[ \] **代码风格检查 (CI/CD)**  
  * 在 GitHub/GitLab 仓库配置 Action。  
  * 每次 Push 自动运行 cargo fmt \--check 和 cargo clippy。  
  * *目的*：在过程性资料中展示你们对代码质量的自动化控制。  
* \[ \] **分支管理策略**  
  * main: 稳定分支 (永远可编译)。  
  * dev: 开发主分支。  
  * feat/xxx: 功能特性分支。  
  * *目的*：提交记录清晰，证明不是“拼凑”的代码。

## **第二阶段：文档驱动开发 (对应评分：30%)**

*不要等写完代码再写文档，要同步进行*

* \[ \] **设计文档：架构篇 (Markdown)**  
  * 画一张全景架构图（Kernel, User, Hardware）。  
  * 解释为什么选 Rust（内存安全）+ 为什么兼容 POSIX（生态丰富）。  
* \[ \] **设计文档：内存管理篇**  
  * **重点**：解释你的物理页分配算法（如伙伴算法）和虚拟内存映射逻辑。  
  * *加分项*：画出虚拟地址空间布局图（SV39 Layout）。  
* \[ \] **设计文档：进程调度篇**  
  * 描述 PCB (TaskControlBlock) 的结构。  
  * 画出进程状态流转图 (Ready \-\> Running \-\> Blocked)。  
* \[ \] **测试报告**  
  * 记录每个模块的单元测试结果。  
  * 截图展示 Shell 运行脚本成功的画面。

## **第三阶段：教学价值构建 (对应评分：10%)**

*这是拉开分数的关键，把自己当成助教*

* \[ \] **编写《Rust OS 踩坑指南》**  
  * 记录 5-10 个开发中遇到的典型 Bug（如：借用检查器报错、死锁、并发问题）。  
  * 格式：问题描述 \-\> 错误代码 \-\> 原因分析 \-\> 解决方案。  
* \[ \] **制作“填空式”实验指导书**  
  * 选取 1-2 个核心功能（如：系统调用入口），把关键代码挖空。  
  * 编写对应的引导文档，教初学者如何把空填上。  
  * *目的*：直接回应“有助于操作系统教学”的要求。

## **第四阶段：演示与答辩准备 (对应评分：20%)**

*评委只有 10 分钟时间了解你*

* \[ \] **可视化仪表盘 (最强加分项)**  
  * 只要能打印日志，就写一个简单的 Python/Web 脚本，通过串口读取日志，在电脑屏幕上实时画出内存占用曲线或进程切换动画。  
  * 话术：“为了让教学更直观，我们开发了可视化观测工具...”  
* \[ \] **演示脚本 (Script)**  
  * 准备 3 个层级的 Demo：  
    1. **基础**：Boot 成功，打印 Hello World。  
    2. **进阶**：运行 ls, mkdir 等文件操作。  
    3. **杀手级**：运行一个 Shell 脚本（含管道 | 和重定向 \>），甚至在这个 Shell 里运行一个简单的 C 语言编写的小游戏（如 2048 命令行版）。  
* \[ \] **PPT 逻辑**  
  * 10% 自我介绍  
  * 20% 架构设计 (图表为主)  
  * 30% 难点攻克 (Rust 与 POSIX 结合的挑战)  
  * 40% Live Demo (录屏备份，防止翻车)

## **过程性资料检查**

* \[ \] 确保 Git Log 有至少 1-2 个月的连续提交记录。  
* \[ \] 导出 GitHub Issues/PR 讨论记录（如果有），证明团队协作。